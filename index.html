<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>éªŒè¯å…¥å£</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="wrap">
    <div class="banner">
      <h1 id="title">åŠ è½½ä¸­â€¦</h1>
      <p class="banner-sub">ç­”é¢˜å¾—ç§¯åˆ†æ‰èƒ½è§£é”å“¦~</p>
    </div>

    <div id="questions"></div>

    <button class="btn" id="submitBtn" disabled>éªŒè¯å£ä»¤</button>
    <div class="msg" id="msg"></div>
  </div>

  <!-- å¤±è´¥å¼¹çª— -->
  <div class="dialog-overlay" id="errorDialog">
    <div class="dialog-wrapper error">
      <img class="dialog-float-img" src="images/error.png" alt="" />
      <div class="dialog-box">
        <div class="dialog-text" id="errorDialogText">è¿˜å·®ä¸€ç‚¹ç‚¹ï¼Œå†æƒ³æƒ³</div>
        <button class="dialog-btn" id="errorBtn">å†è¯•è¯•</button>
      </div>
    </div>
  </div>

  <!-- æˆåŠŸå¼¹çª— -->
  <div class="dialog-overlay" id="successDialog">
    <div class="dialog-wrapper success">
      <div class="dialog-box">
        <div class="dialog-text">ğŸ‰æ­å–œå®å®ç­”å¯¹äº†æ‰€æœ‰é—®é¢˜ï¼ï¼</div>
        <button class="dialog-btn" id="successBtn">æŸ¥çœ‹æ¥è‡ªåº·åº·çš„ä¿¡</button>
      </div>
      <img class="dialog-float-img" src="images/success.png" alt="" />
    </div>
  </div>

<script>
  const QUIZ_URL = "./quiz.json";
  const LETTER_URL = "./letter.html";

  function normalizeInput(s) {
    return (s ?? "").trim().toLowerCase().replace(/\s+/g, " ");
  }

  function bufToHex(buf) {
    const b = new Uint8Array(buf);
    return Array.from(b).map(x => x.toString(16).padStart(2, "0")).join("");
  }

  function bufToBase64Url(buf) {
    const b = new Uint8Array(buf);
    let binary = "";
    for (let i = 0; i < b.length; i++) binary += String.fromCharCode(b[i]);
    return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }

  // çº¯ JS SHA-256 å®ç°ï¼ˆå…¼å®¹é HTTPS ç¯å¢ƒï¼‰
  const _sha256 = (() => {
    const K = new Uint32Array([
      0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
      0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
      0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
      0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
      0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
      0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
      0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
      0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
    ]);
    function rotr(x,n){return(x>>>n)|(x<<(32-n));}
    function Ch(x,y,z){return(x&y)^(~x&z);}
    function Maj(x,y,z){return(x&y)^(x&z)^(y&z);}
    function S0(x){return rotr(x,2)^rotr(x,13)^rotr(x,22);}
    function S1(x){return rotr(x,6)^rotr(x,11)^rotr(x,25);}
    function s0(x){return rotr(x,7)^rotr(x,18)^(x>>>3);}
    function s1(x){return rotr(x,17)^rotr(x,19)^(x>>>10);}

    return function sha256(bytes) {
      let H0=0x6a09e667,H1=0xbb67ae85,H2=0x3c6ef372,H3=0xa54ff53a;
      let H4=0x510e527f,H5=0x9b05688c,H6=0x1f83d9ab,H7=0x5be0cd19;
      const len = bytes.length;
      const bitLen = len * 8;
      const padded = new Uint8Array(((len + 9 + 63) & ~63));
      padded.set(bytes);
      padded[len] = 0x80;
      const dv = new DataView(padded.buffer);
      dv.setUint32(padded.length - 4, bitLen, false);
      const W = new Uint32Array(64);
      for (let off = 0; off < padded.length; off += 64) {
        for (let i=0;i<16;i++) W[i]=dv.getUint32(off+i*4,false);
        for (let i=16;i<64;i++) W[i]=(s1(W[i-2])+W[i-7]+s0(W[i-15])+W[i-16])|0;
        let a=H0,b=H1,c=H2,d=H3,e=H4,f=H5,g=H6,h=H7;
        for (let i=0;i<64;i++){
          const t1=(h+S1(e)+Ch(e,f,g)+K[i]+W[i])|0;
          const t2=(S0(a)+Maj(a,b,c))|0;
          h=g;g=f;f=e;e=(d+t1)|0;d=c;c=b;b=a;a=(t1+t2)|0;
        }
        H0=(H0+a)|0;H1=(H1+b)|0;H2=(H2+c)|0;H3=(H3+d)|0;
        H4=(H4+e)|0;H5=(H5+f)|0;H6=(H6+g)|0;H7=(H7+h)|0;
      }
      const out = new Uint8Array(32);
      const ov = new DataView(out.buffer);
      ov.setUint32(0,H0);ov.setUint32(4,H1);ov.setUint32(8,H2);ov.setUint32(12,H3);
      ov.setUint32(16,H4);ov.setUint32(20,H5);ov.setUint32(24,H6);ov.setUint32(28,H7);
      return out;
    };
  })();

  function sha256Bytes(str) {
    return _sha256(new TextEncoder().encode(str));
  }

  async function sha256Hex(str) {
    if (typeof crypto !== "undefined" && crypto.subtle) {
      try {
        const enc = new TextEncoder().encode(str);
        const digest = await crypto.subtle.digest("SHA-256", enc);
        return bufToHex(digest);
      } catch(e) { /* fallback below */ }
    }
    return bufToHex(sha256Bytes(str));
  }

  async function sha256Raw(str) {
    if (typeof crypto !== "undefined" && crypto.subtle) {
      try {
        const enc = new TextEncoder().encode(str);
        return await crypto.subtle.digest("SHA-256", enc);
      } catch(e) { /* fallback below */ }
    }
    return sha256Bytes(str).buffer;
  }

  function setMsg(text) {
    document.getElementById("msg").textContent = text || "";
  }

  function enableSubmitIfReady(state, quiz) {
    const ok = quiz.questions.every(q => {
      const v = state[q.id];
      return typeof v === "string" && v.length > 0;
    });
    document.getElementById("submitBtn").disabled = !ok;
  }

  function clearAllHints() {
    document.querySelectorAll(".error-hint").forEach(el => el.classList.remove("show"));
  }

  function showAllHints() {
    document.querySelectorAll(".error-hint").forEach(el => {
      el.classList.add("show");
      // éšè—åŒä¸€cardä¸­çš„åŸå§‹hintï¼Œé¿å…ä¸¤è¡Œæç¤ºåŒæ—¶æ˜¾ç¤º
      const card = el.closest(".card");
      if (card) {
        const origHint = card.querySelector(".hint");
        if (origHint) origHint.style.display = "none";
      }
    });
  }

  function renderQuestion(q, state, onChange) {
    const card = document.createElement("div");
    card.className = "card";
    card.dataset.qid = q.id;

    const label = document.createElement("label");
    label.textContent = q.prompt;
    card.appendChild(label);

    if (q.type === "number_unit") {
      const wrap = document.createElement("div");
      wrap.className = "number-unit-wrap";

      const input = document.createElement("input");
      input.type = "text";
      input.inputMode = "numeric";
      input.placeholder = q.placeholder || "";
      input.value = state[q.id] || "";
      input.addEventListener("input", () => {
        const filtered = input.value.replace(/[^\d]/g, "");
        if (input.value !== filtered) input.value = filtered;
        onChange(q.id, input.value, false);
      });
      wrap.appendChild(input);

      const unit = document.createElement("span");
      unit.className = "unit-label";
      unit.textContent = q.unit || "";
      wrap.appendChild(unit);

      card.appendChild(wrap);

    } else if (q.type === "limit_text") {
      const input = document.createElement("input");
      input.type = "text";
      input.className = "limit-text-input";
      input.placeholder = q.placeholder || "";
      input.value = state[q.id] || "";
      const maxLen = q.maxlength || 2;
      let composing = false;

      input.addEventListener("compositionstart", () => { composing = true; });
      input.addEventListener("compositionend", () => {
        composing = false;
        onChange(q.id, input.value, false);
      });

      input.addEventListener("input", () => {
        if (!composing) {
          onChange(q.id, input.value, false);
        }
      });

      input.addEventListener("blur", () => {
        const val = input.value;
        if ([...val].length > maxLen) {
          input.classList.add("overflow");
          input.value = [...val].slice(0, maxLen).join("");
          onChange(q.id, input.value, false);
          setTimeout(() => input.classList.remove("overflow"), 400);
        }
      });

      card.appendChild(input);

    } else if (q.type === "dialpad") {
      const wrap = document.createElement("div");
      wrap.className = "dialpad-wrap";

      const input = document.createElement("input");
      input.type = "text";
      input.readOnly = true;
      input.placeholder = q.placeholder || "";
      input.value = state[q.id] || "";
      wrap.appendChild(input);

      const pad = document.createElement("div");
      pad.className = "dialpad";

      const keys = ["1","2","3","4","5","6","7","8","9","*","0","#"];
      keys.forEach(k => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "dialpad-key";
        btn.textContent = k;
        btn.addEventListener("click", () => {
          input.value += k;
          onChange(q.id, input.value, false);
        });
        pad.appendChild(btn);
      });

      // åˆ é™¤é”®
      const delBtn = document.createElement("button");
      delBtn.type = "button";
      delBtn.className = "dialpad-key key-delete";
      delBtn.textContent = "âŒ«";
      delBtn.addEventListener("click", () => {
        input.value = input.value.slice(0, -1);
        onChange(q.id, input.value, false);
      });
      pad.appendChild(delBtn);

      wrap.appendChild(pad);
      card.appendChild(wrap);

    } else if (q.type === "text") {
      const input = document.createElement("input");
      input.type = "text";
      input.placeholder = q.placeholder || "";
      input.value = state[q.id] || "";
      input.addEventListener("input", () => onChange(q.id, input.value, false));
      card.appendChild(input);

    } else if (q.type === "choice") {
      const choices = document.createElement("div");
      choices.className = "choices";
      (q.options || []).forEach(opt => {
        const item = document.createElement("div");
        item.className = "choice" + ((state[q.id] === opt.key) ? " active" : "");
        item.textContent = `${opt.key}. ${opt.label}`;
        item.addEventListener("click", () => onChange(q.id, opt.key, true));
        choices.appendChild(item);
      });
      card.appendChild(choices);

    } else if (q.type === "voice_record") {
      const wrap = document.createElement("div");
      wrap.className = "voice-record-wrap";

      // æ—¶é•¿æ˜¾ç¤º
      const durationDisplay = document.createElement("div");
      durationDisplay.className = "voice-duration";
      durationDisplay.textContent = "00:00";
      wrap.appendChild(durationDisplay);

      // å½•éŸ³æŒ‰é’®
      const recordBtn = document.createElement("button");
      recordBtn.type = "button";
      recordBtn.className = "voice-record-btn";
      
      const icon = document.createElement("span");
      icon.className = "voice-icon";
      icon.textContent = "ğŸ¤";
      recordBtn.appendChild(icon);
      
      // æ³¢å½¢åŠ¨ç”»å®¹å™¨ï¼ˆæ”¾åœ¨æŒ‰é’®å†…éƒ¨ï¼‰
      const waveform = document.createElement("div");
      waveform.className = "voice-waveform";
      for (let i = 0; i < 7; i++) {
        const bar = document.createElement("div");
        bar.className = "voice-wave-bar";
        waveform.appendChild(bar);
      }
      recordBtn.appendChild(waveform);
      
      const text = document.createElement("span");
      text.className = "voice-text";
      text.textContent = "æŒ‰ä½è¯´è¯";
      recordBtn.appendChild(text);

      let startTime = null;
      let animationFrame = null;
      let completed = false;
      const minDuration = q.min_duration || 120;

      const updateDuration = () => {
        if (startTime) {
          const elapsed = Math.floor((Date.now() - startTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          durationDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
          
          if (elapsed >= minDuration && !completed) {
            completed = true;
            durationDisplay.classList.add("complete");
            onChange(q.id, "completed", false);
          }
        }
        animationFrame = requestAnimationFrame(updateDuration);
      };

      let permissionGranted = false;

      const startRecording = async () => {
        if (!permissionGranted) {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            stream.getTracks().forEach(track => track.stop());
            permissionGranted = true;
          } catch (e) {
            console.warn("éº¦å…‹é£æƒé™æœªæˆäºˆï¼Œç»§ç»­æ¨¡æ‹Ÿå½•éŸ³");
            permissionGranted = true;
          }
        }

        // æ¯æ¬¡æŒ‰ä½éƒ½ä»0å¼€å§‹
        completed = false;
        durationDisplay.classList.remove("complete");
        onChange(q.id, "", false);

        recordBtn.classList.add("recording");
        recordBtn.querySelector(".voice-text").textContent = "æ­£åœ¨å½•éŸ³...";
        startTime = Date.now();
        updateDuration();
      };

      const stopRecording = () => {
        if (!startTime) return;
        startTime = null;
        recordBtn.classList.remove("recording");
        recordBtn.querySelector(".voice-text").textContent = "æŒ‰ä½è¯´è¯";
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
          animationFrame = null;
        }

        if (!completed) {
          durationDisplay.textContent = "00:00";
        }
      };

      // PCç«¯å’Œç§»åŠ¨ç«¯éƒ½æ”¯æŒ
      recordBtn.addEventListener("mousedown", startRecording);
      recordBtn.addEventListener("mouseup", stopRecording);
      recordBtn.addEventListener("mouseleave", stopRecording);
      recordBtn.addEventListener("touchstart", (e) => {
        e.preventDefault();
        startRecording();
      });
      recordBtn.addEventListener("touchend", (e) => {
        e.preventDefault();
        stopRecording();
      });
      recordBtn.addEventListener("touchcancel", stopRecording);

      wrap.appendChild(recordBtn);
      card.appendChild(wrap);
    }

    // é”™è¯¯æç¤ºï¼ˆé»˜è®¤éšè—ï¼‰
    if (q.error_hint) {
      const hint = document.createElement("div");
      hint.className = "error-hint";
      hint.id = "hint-" + q.id;
      hint.textContent = `æç¤ºï¼š${q.error_hint}`;
      card.appendChild(hint);
    }

    if (q.hint) {
      const hint = document.createElement("div");
      hint.className = "hint";
      hint.textContent = `æç¤ºï¼š${q.hint}`;
      card.appendChild(hint);
    }

    return card;
  }

  async function main() {
    const resp = await fetch(QUIZ_URL + "?_t=" + Date.now());
    if (!resp.ok) throw new Error("æ— æ³•åŠ è½½ quiz.json");
    const quiz = await resp.json();

    document.getElementById("title").textContent = quiz.title || "éªŒè¯å…¥å£";

    const state = {};
    const container = document.getElementById("questions");

    function rerender() {
      container.innerHTML = "";
      quiz.questions.forEach(q => {
        container.appendChild(renderQuestion(q, state, (id, val, shouldRerender) => {
          state[id] = val;
          if (shouldRerender) {
            rerender();
          }
          enableSubmitIfReady(state, quiz);
          setMsg("");
          clearAllHints();
        }));
      });
    }

    rerender();
    enableSubmitIfReady(state, quiz);

    document.getElementById("submitBtn").addEventListener("click", async () => {
      setMsg("éªŒè¯ä¸­â€¦");
      clearAllHints();

      // é€é¢˜æ ¡éªŒï¼ˆæ”¯æŒå¤šç­”æ¡ˆ answer_hashesï¼‰
      for (const q of quiz.questions) {
        // voice_record ç±»å‹åªæ£€æŸ¥æ˜¯å¦å®Œæˆ
        if (q.type === "voice_record") {
          if (state[q.id] !== "completed") {
            setMsg("");
            document.getElementById("errorDialogText").textContent = "è¿˜æ²¡å”±å¤Ÿæ—¶é•¿å‘¢ï¼Œç»§ç»­åŠ æ²¹~";
            document.getElementById("errorDialog").classList.add("show");
            return;
          }
          continue;
        }

        const raw = state[q.id] ?? "";
        const normalized = normalizeInput(raw);
        const payload = `${normalized}:${q.salt}`;
        const h = await sha256Hex(payload);

        const hashes = q.answer_hashes || (q.answer_hash ? [q.answer_hash] : []);
        if (!hashes.includes(h)) {
          setMsg("");
          document.getElementById("errorDialogText").textContent = "å†å¥½å¥½æƒ³æƒ³å‘¢ï¼Ÿ";
          document.getElementById("errorDialog").classList.add("show");
          return;
        }
      }

      // å…¨éƒ¨é€šè¿‡ -> ç”Ÿæˆ token
      // ä½¿ç”¨æ¯é¢˜çš„ token_hashï¼ˆå›ºå®šå€¼ï¼‰ï¼Œä¿è¯ä¸åŒæ­£ç¡®ç­”æ¡ˆäº§ç”ŸåŒä¸€ä¸ª token
      // voice_record ä¸å‚ä¸ token ç”Ÿæˆ
      const tokenSource = quiz.questions
        .filter(q => q.type !== "voice_record")
        .map(q => `${q.id}=${q.token_hash}`)
        .join("|");

      const tokenRaw = await sha256Raw(tokenSource);
      const tokenB64u = bufToBase64Url(tokenRaw);

      setMsg("");
      const targetUrl = `${LETTER_URL}#t=${tokenB64u}`;
      document.getElementById("successDialog").classList.add("show");
      document.getElementById("successBtn").addEventListener("click", () => {
        window.location.href = targetUrl;
      });
    });

    // å¤±è´¥å¼¹çª—å…³é—­ â†’ é‡ç½®è¯­éŸ³å½•åˆ¶çŠ¶æ€ + é‡æ–°æ¸²æŸ“ + å±•ç¤ºæ‰€æœ‰æç¤º
    document.getElementById("errorBtn").addEventListener("click", () => {
      document.getElementById("errorDialog").classList.remove("show");
      // é‡ç½®è¯­éŸ³å½•åˆ¶é¢˜çš„çŠ¶æ€
      quiz.questions.forEach(q => {
        if (q.type === "voice_record") {
          state[q.id] = "";
        }
      });
      // å…ˆé‡æ–°æ¸²æŸ“ä»¥é‡ç½®è¯­éŸ³å½•åˆ¶UI
      rerender();
      enableSubmitIfReady(state, quiz);
      // æ¸²æŸ“å®Œæˆåå†å±•ç¤ºæ‰€æœ‰æç¤º
      showAllHints();
    });
  }

  main().catch(err => {
    console.error(err);
    setMsg("åŠ è½½å¤±è´¥ï¼šè¯·æ£€æŸ¥ quiz.json æ˜¯å¦å¯è®¿é—®ã€‚");
  });
</script>
</body>
</html>
